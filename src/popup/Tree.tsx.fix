import React, { useMemo, useRef, useState } from 'react'
import type { TreeDocument, TreeNode, TreeUIState } from '../models'
import { filterTree, highlight } from '../search'
import { insertChild, removeNode, updateNode, moveNode, moveMultipleNodes, updateNodeComment } from '../treeOps'
import { upsertNodes } from './sqlStorage'   // фолбэк, если не передадют onCommitNodes
import { getUniversalItemsToAdd, universalItemToTreeNode, getSourceDescription, copySelectedNodes, deleteSourceNodesForIntraTreeMove } from '../universalAdd'
type Props = {
  doc: TreeDocument
  onAddRootCategory: () => void
  onAddCurrentTabToRoot: () => void
  forceExpand?: boolean
  selectedTab?: { id: number; title: string; url: string } | null
  /** Если передать — именно он будет коммитить узлы (рекомендуется вызывать App.updateNodesFor) */
  onCommitNodes?: (docId: string, nodes: TreeNode[]) => Promise<void> | void
  // Состояние UI дерева
  uiState: TreeUIState
  onUpdateUIState: (updater: (prev: TreeUIState) => TreeUIState) => void
  // Новые пропсы для системы выделения
  selectionMode?: boolean
  moveMode?: boolean
  isNodeSelected?: (nodeId: string) => boolean
  onToggleNodeSelection?: (node: TreeNode) => void
  // Групповые операции
  onDeleteSelected?: () => void
  removeNodesFromSelection?: (treeId: string, nodeIds: string[]) => void
  // Данные всех деревьев для поддержки межпроектных переносов
  allTrees?: TreeDocument[]
  onUpdateTreeNodes?: (treeId: string, nodes: TreeNode[]) => Promise<void>
  // Глобальные функции выделения для междеревных операций
  globalIsNodeSelected?: (treeId: string, nodeId: string) => boolean
}

/* ---------- helpers для Chrome API (Promise-обёртки) ---------- */
function pTabsQuery(q: chrome.tabs.QueryInfo): Promise<chrome.tabs.Tab[]> {
  return new Promise(res => chrome.tabs.query(q, res))
}
function pTabsCreate(c: chrome.tabs.CreateProperties): Promise<chrome.tabs.Tab> {
  return new Promise(res => chrome.tabs.create(c, res))
}
function pTabsUpdate(tabId: number, props: chrome.tabs.UpdateProperties) {
  return new Promise<chrome.tabs.Tab>((res, rej) => {
    chrome.tabs.update(tabId, props, (tab) => {
      if (chrome.runtime.lastError || !tab) return rej(chrome.runtime.lastError ?? new Error("No tab"));
      res(tab);
    });
  });
}
function pWindowsUpdate(windowId: number, props: chrome.windows.UpdateInfo): Promise<chrome.windows.Window | undefined> {
  return new Promise(res => chrome.windows.update(windowId, props, res))
}
function pTabsGroup(opts: chrome.tabs.GroupOptions): Promise<number> {
  return new Promise((res, rej) => chrome.tabs.group(opts, gid => {
    const err = chrome.runtime.lastError
    if (err) rej(err); else res(gid)
  }))
}
function pTabGroupsGet(groupId: number): Promise<chrome.tabGroups.TabGroup> {
  return new Promise((res, rej) => chrome.tabGroups.get(groupId, g => {
    const err = chrome.runtime.lastError
    if (err) rej(err); else res(g)
  }))
}
function pTabGroupsUpdate(groupId: number, info: chrome.tabGroups.UpdateProperties): Promise<chrome.tabGroups.TabGroup> {
  return new Promise((res, rej) => chrome.tabGroups.update(groupId, info, g => {
    const err = chrome.runtime.lastError
    if (err) rej(err); else res(g!)
  }))
}

const normUrl = (u?: string) => (u ? u.split('#')[0] : '')

/** Открыть/активировать URL с учётом групп вкладок. */
async function openOrFocusUrl(url: string, docTitle: string) {
  const target = normUrl(url)
  if (!target) return

  // 1) Уже открыт?
  const all = await pTabsQuery({})
  const existing = all.find(t => normUrl(t.url || '') === target)
  if (existing?.id) {
    if (typeof existing.windowId === 'number') await pWindowsUpdate(existing.windowId, { focused: true })
    await pTabsUpdate(existing.id, { active: true })
    return
  }

  // 2) Получаем информацию о "родительской" вкладке и группе
  const sessionData = await chrome.storage.session.get(['vb_lastActiveTabId', 'vb_lastActiveGroupId']);
  const parentTabId = sessionData.vb_lastActiveTabId;
  const parentGroupId = sessionData.vb_lastActiveGroupId;

  const [activeWinTab] = await pTabsQuery({ active: true, currentWindow: true })
  const winId = activeWinTab?.windowId ?? (await pTabsQuery({ currentWindow: true }))[0]?.windowId
  const created = await pTabsCreate({ url: target, active: true, windowId: winId })

  if (!chrome.tabGroups || typeof created.id !== 'number') return

  // 3) Приоритеты для выбора группы:
  // а) Группа с названием дерева
  const tabsInWindow = await pTabsQuery({ windowId: created.windowId })
  const uniqueGroupIds = Array.from(new Set(
    tabsInWindow.map(t => (typeof t.groupId === 'number' ? t.groupId : -1)).filter(gid => gid >= 0)
  ))
  let targetGroupId: number | null = null
  for (const gid of uniqueGroupIds) {
    try {
      const g = await pTabGroupsGet(gid)
      if (g.title === docTitle) { targetGroupId = gid; break }
    } catch {}
  }
  if (targetGroupId !== null) { await pTabsGroup({ tabIds: created.id, groupId: targetGroupId }); return }

  // б) Группа "родительской" вкладки
  if (typeof parentGroupId === 'number' && parentGroupId >= 0) {
    try {
      // Проверяем, что группа существует в том же окне
      const groupStillExists = uniqueGroupIds.includes(parentGroupId);
      if (groupStillExists) {
        await pTabsGroup({ tabIds: created.id, groupId: parentGroupId });
        return;
      }
    } catch {}
  }

  // в) Группа текущей активной вкладки (запасной вариант)
  const activeGroupId = (activeWinTab && typeof activeWinTab.groupId === 'number' && activeWinTab.groupId >= 0)
    ? activeWinTab.groupId : -1
  if (activeGroupId >= 0) { await pTabsGroup({ tabIds: created.id, groupId: activeGroupId }); return }

  // г) Создаём новую группу с названием дерева
  try {
    const newGroupId = await pTabsGroup({ tabIds: created.id })
    await pTabGroupsUpdate(newGroupId, { title: docTitle })
  } catch {}
}

/* ---------- helpers для «выделенных вкладок» ---------- */
const isNormalTab = (t: chrome.tabs.Tab) =>
  !!(t.url && !t.url.startsWith('chrome://') && !t.url.startsWith('chrome-extension://'))

const toNode = (t: chrome.tabs.Tab): TreeNode => ({
  id: crypto.randomUUID(),
  title: (t.title || t.url || '').trim() || 'Без названия',
  url: t.url || '',
  children: []
})


/* ------------------- UI helpers ------------------- */

const TitleWithHighlight: React.FC<{ text: string, q: string, isLink?: boolean }> = ({ text, q, isLink }) => {
  const parts = useMemo(() => highlight(text, q), [text, q])
  return (
    <>
      {parts.map((p,i)=> typeof p==='string' ? <span key={i}>{p}</span> : <mark key={i}>{p.mark}</mark>)}
      {isLink && <span className="muted"> ↗</span>}
    </>
  )
}

function faviconForUrl(url?: string): string {
  if (!url) return ''
  if (!/^https?:/i.test(url)) return ''
  return `https://www.google.com/s2/favicons?domain_url=${encodeURIComponent(url)}&sz=16`
}

/** max глубина дерева */
function computeMaxDepth(nodes: TreeNode[], depth = 0): number {
  let m = depth
  for (const n of nodes) m = Math.max(m, computeMaxDepth(n.children || [], depth + 1))
  return m
}

/** Обрезка дерева до depth (включительно). depth=-1 — без обрезки */
function cutTreeToDepth(nodes: TreeNode[], depth: number, cur = 0): TreeNode[] {
  if (depth < 0) return nodes
  return nodes.map(n => ({
    ...n,
    children: cur >= depth ? [] : cutTreeToDepth(n.children || [], depth, cur + 1)
  }))
}

const NodeView: React.FC<{
  node: TreeNode
  q: string
  allNodes: TreeNode[]
  setAllNodes: (ns: TreeNode[]) => void
  docId: string
  docTitle: string
  forceExpand?: boolean
  selectedTab?: { id: number; title: string; url: string } | null
  depth?: number
  maxLevel?: number
  expandedNodes: Set<string>
  onToggleExpanded: (nodeId: string, isExpanded: boolean) => void
  // Новые пропсы для системы выделения
  selectionMode?: boolean
  moveMode?: boolean
  isNodeSelected?: (nodeId: string) => boolean
  onToggleNodeSelection?: (node: TreeNode) => void
  removeNodesFromSelection?: (treeId: string, nodeIds: string[]) => void
  // Параметры для универсального переноса
  allTrees?: TreeDocument[]
  onUpdateTreeNodes?: (treeId: string, nodes: TreeNode[]) => Promise<void>
  globalIsNodeSelected?: (treeId: string, nodeId: string) => boolean
}> = ({
  node,
  q,
  allNodes,
  setAllNodes,
  docId,
  docTitle,
  forceExpand,
  selectedTab,
  depth = 0,
  maxLevel = -1,
  expandedNodes,
  onToggleExpanded,
  // Новые пропсы для системы выделения
  selectionMode = false,
  moveMode = false,
  isNodeSelected = () => false,
  onToggleNodeSelection = () => {},
  removeNodesFromSelection = () => {},
  // Параметры для универсального переноса
  allTrees = [],
  onUpdateTreeNodes,
  globalIsNodeSelected = () => false,
}) => {
  const [renaming, setRenaming] = useState(false)
  const [title, setTitle] = useState(node.title)
  const [commentText, setCommentText] = useState(node.comment || '')
  const [editingComment, setEditingComment] = useState(false)
  const isLink = !!node.url
  const hasChildren = (node.children?.length || 0) > 0
  const isSelected = isNodeSelected(node.id)

  // Определяем, развёрнут ли узел
  const isExpanded = expandedNodes.has(node.id)
  const isExplicitlyClosed = expandedNodes.has(`closed:${node.id}`)
  const effectiveOpen = forceExpand ? !isExplicitlyClosed : isExpanded

  // Обработчики для перетаскивания
  const onDragStart = (e: React.DragEvent) => {
    e.stopPropagation()
    e.dataTransfer.setData('text/plain', JSON.stringify({
      nodeId: node.id,
      docId,
      title: node.title,
      url: node.url,
    }))
  }

  const onDragOver = (e: React.DragEvent) => {
    e.preventDefault()
    e.stopPropagation()
  }

  const onDrop = async (e: React.DragEvent) => {
    e.preventDefault()
    e.stopPropagation()

    try {
      const data = JSON.parse(e.dataTransfer.getData('text/plain'))
      if (!data?.nodeId) return

      // Проверяем, не пытаемся ли мы перетащить узел на самого себя
      if (data.nodeId === node.id) return

      // Проверяем, не пытаемся ли мы перетащить родителя на его потомка
      let isDescendant = false
      const checkDescendant = (nodes: TreeNode[], targetId: string): boolean => {
        for (const n of nodes) {
          if (n.id === targetId) return true
          if (n.children && checkDescendant(n.children, targetId)) return true
        }
        return false
      }

      if (data.docId === docId) {
        const findNode = (nodes: TreeNode[], id: string): TreeNode | null => {
          for (const n of nodes) {
            if (n.id === id) return n
            if (n.children) {
              const found = findNode(n.children, id)
              if (found) return found
            }
          }
          return null
        }
        const draggedNode = findNode(allNodes, data.nodeId)
        if (draggedNode && draggedNode.children) {
          isDescendant = checkDescendant(draggedNode.children, node.id)
        }
      }

      if (isDescendant) {
        console.warn('Cannot move parent to its descendant')
        return
      }

      // Если перетаскиваем из того же дерева
      if (data.docId === docId) {
        // Внутри одного дерева - используем moveNode
        const newNodes = moveNode(allNodes, data.nodeId, node.id)
        if (newNodes) {
          setAllNodes(newNodes)
          // Раскрываем узел, в который перетащили
          onToggleExpanded(node.id, true)
        }
      } else {
        // Между деревьями - используем универсальный перенос
        // Получаем исходное дерево
        const sourceTree = allTrees.find(t => t.id === data.docId)
        if (!sourceTree || !onUpdateTreeNodes) return

        // Создаем универсальный элемент для переноса
        const universalItems = getUniversalItemsToAdd([{
          treeId: data.docId,
          nodeId: data.nodeId,
          title: data.title,
          url: data.url
        }], allTrees)

        if (universalItems.length === 0) return

        // Преобразуем в узел дерева
        const newNode = universalItemToTreeNode(universalItems[0])
        if (!newNode) return

        // Добавляем в целевое дерево
        const updatedNodes = insertChild(allNodes, node.id, newNode)
        setAllNodes(updatedNodes)
        
        // Удаляем из исходного дерева
        const sourceNodes = sourceTree.nodes.filter(n => n.id !== data.nodeId)
        await onUpdateTreeNodes(data.docId, sourceNodes)

        // Раскрываем узел, в который перетащили
        onToggleExpanded(node.id, true)
      }
    } catch (error) {
      console.error('Error during drag and drop:', error)
    }
  }

  // Обработчики для редактирования
  const startRename = (e: React.MouseEvent) => {
    e.stopPropagation()
    setRenaming(true)
  }

  const commitRename = () => {
    if (title.trim() === '') {
      setTitle(node.title)
      setRenaming(false)
      return
    }

    if (title !== node.title) {
      const newNodes = updateNode(allNodes, node.id, { title })
      if (newNodes) setAllNodes(newNodes)
    }
    setRenaming(false)
  }

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      e.preventDefault()
      commitRename()
    } else if (e.key === 'Escape') {
      e.preventDefault()
      setTitle(node.title)
      setRenaming(false)
    }
  }

  // Обработчик для редактирования комментария
  const editComment = (e: React.MouseEvent) => {
    e.stopPropagation()
    setCommentText(node.comment || '')
    setEditingComment(true)
  }

  const commitComment = () => {
    const trimmedComment = commentText.trim()
    const newComment = trimmedComment === '' ? undefined : trimmedComment
    
    if (newComment !== node.comment) {
      const newNodes = updateNodeComment(allNodes, node.id, newComment)
      if (newNodes) setAllNodes(newNodes)
    }
    setEditingComment(false)
  }

  const handleCommentKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      commitComment()
    } else if (e.key === 'Escape') {
      e.preventDefault()
      setCommentText(node.comment || '')
      setEditingComment(false)
    }
  }

  // Обработчики для добавления
  const addCategoryHere = (e: React.MouseEvent) => {
    e.stopPropagation()
    const title = prompt('Название категории:')
    if (!title) return

    const newNode: TreeNode = {
      id: crypto.randomUUID(),
      title,
      children: []
    }

    const newNodes = insertChild(allNodes, node.id, newNode)
    if (newNodes) {
      setAllNodes(newNodes)
      onToggleExpanded(node.id, true)
    }
  }

  const addSelectedTabHere = async (e: React.MouseEvent) => {
    e.stopPropagation()
    
    // Проверяем, в режиме выделения или нет
    if (selectionMode) {
      // В режиме выделения - добавляем выделенные элементы
      try {
        // Получаем универсальные элементы для добавления
        const universalItems = getUniversalItemsToAdd(
          allTrees.flatMap(tree => 
            Array.from(globalIsNodeSelected ? 
              tree.nodes.filter(n => globalIsNodeSelected(tree.id, n.id)).map(n => ({
                treeId: tree.id,
                nodeId: n.id,
                title: n.title,
                url: n.url
              })) : []
            )
          ),
          allTrees
        )
        
        if (universalItems.length === 0) {
          alert('Нет выделенных элементов для добавления')
          return
        }
        
        // Получаем описание операции
        const description = getSourceDescription(universalItems)
        
        // Подтверждение операции
        const confirmMessage = moveMode 
          ? `Переместить ${description} в "${node.title}"?`
          : `Копировать ${description} в "${node.title}"?`
          
        if (!confirm(confirmMessage)) return
        
        // Создаем новые узлы из универсальных элементов
        const newNodes = universalItems
          .map(item => universalItemToTreeNode(item))
          .filter(Boolean) as TreeNode[]
          
        if (newNodes.length === 0) return
        
        // Добавляем узлы в текущее дерево
        let updatedNodes = [...allNodes]
        for (const newNode of newNodes) {
          updatedNodes = insertChild(updatedNodes, node.id, newNode)
        }
        
        setAllNodes(updatedNodes)
        onToggleExpanded(node.id, true)
        
        // Если в режиме перемещения, удаляем исходные узлы
        if (moveMode) {
          // Группируем по деревьям для оптимизации
          const nodesByTree: Record<string, string[]> = {}
          
          universalItems.forEach(item => {
            if (!item.treeId || !item.nodeId) return
            
            if (!nodesByTree[item.treeId]) {
              nodesByTree[item.treeId] = []
            }
            nodesByTree[item.treeId].push(item.nodeId)
          })
          
          // Удаляем из каждого дерева
          for (const [treeId, nodeIds] of Object.entries(nodesByTree)) {
            // Если это текущее дерево, обновляем локальное состояние
            if (treeId === docId) {
              // Для внутридеревного перемещения используем специальную функцию
              const result = deleteSourceNodesForIntraTreeMove(updatedNodes, nodeIds)
              if (result) {
                setAllNodes(result)
              }
            } else if (onUpdateTreeNodes) {
              // Для междеревного перемещения обновляем через пропсы
              const sourceTree = allTrees.find(t => t.id === treeId)
              if (sourceTree) {
                const updatedSourceNodes = removeMultipleNodes(sourceTree.nodes, nodeIds)
                await onUpdateTreeNodes(treeId, updatedSourceNodes)
              }
            }
            
            // Удаляем из выделения
            removeNodesFromSelection(treeId, nodeIds)
          }
        }
        
      } catch (error) {
        console.error('Error adding selected items:', error)
        alert('Ошибка при добавлении выделенных элементов')
      }
    } else {
      // В обычном режиме - добавляем текущую вкладку
      if (!selectedTab) {
        alert('Нет активной вкладки для добавления')
        return
      }
      
      const newNode: TreeNode = {
        id: crypto.randomUUID(),
        title: selectedTab.title || selectedTab.url || 'Без названия',
        url: selectedTab.url,
        children: []
      }
      
      const newNodes = insertChild(allNodes, node.id, newNode)
      if (newNodes) {
        setAllNodes(newNodes)
        onToggleExpanded(node.id, true)
      }
    }
  }

  // Обработчик для удаления
  const deleteNode = (e: React.MouseEvent) => {
    e.stopPropagation()
    if (!confirm(`Удалить "${node.title}"?`)) return

    const newNodes = removeNode(allNodes, node.id)
    if (newNodes) setAllNodes(newNodes)
  }

  // Обработчик для открытия ссылки
  const openHere = async (e: React.MouseEvent) => {
    e.stopPropagation()
    if (!node.url) return
    await openOrFocusUrl(node.url, docTitle)
  }

  const handleRowClick = (e: React.MouseEvent) => {
    if (selectionMode && onToggleNodeSelection) {
      // В режиме выделения - переключаем выделение
      e.stopPropagation()
      onToggleNodeSelection(node)
      return
    }
    
    // Обычный режим - управление раскрытием или открытие ссылки
    if (!isLink || hasChildren) {
      // При клике помечаем узел как явно управляемый пользователем
      if (isExpanded) {
        // Сворачиваем: удаляем из expanded, добавляем в closed
        onToggleExpanded(node.id, false)
        onToggleExpanded(`closed:${node.id}`, true)
      } else {
        // Раскрываем: добавляем в expanded, удаляем из closed
        onToggleExpanded(node.id, true)
        onToggleExpanded(`closed:${node.id}`, false)
      }
    } else if (isLink && !hasChildren) {
      // Открываем ссылку только если у нее нет дочерних элементов
      openHere(e as any)
    }
  }

  // Определяем класс для точки узла
  const getDotClass = () => {
    if (isLink) {
      // Ссылка с дочерними элементами
      if (hasChildren) {
        return 'link-parent'
      }
      // Обычная ссылка
      return 'link'
    }
    // Папка
    return 'folder'
  }

  return (
    <div className="node" draggable onDragStart={onDragStart} onDragOver={onDragOver} onDrop={onDrop}>
      <div
        className={`node-row ${isSelected ? 'selected' : ''} ${node.comment ? 'has-comment' : ''}`}
        role="treeitem"
        aria-expanded={(!isLink || hasChildren) ? effectiveOpen : undefined}
        tabIndex={-1}
        data-node-id={node.id}
        onClick={handleRowClick}
      >
        {selectionMode && (
          <div 
            className={`selection-checkbox ${isSelected ? 'checked' : ''}`}
            onClick={(e) => {
              e.stopPropagation()
              onToggleNodeSelection?.(node)
            }}
          />
        )}
        <span className={'dot ' + getDotClass()} title={effectiveOpen ? 'Свернуть' : 'Развернуть'} />
        {isLink ? (
          <span className="link-wrap">
            {(() => {
              const src = faviconForUrl(node.url)
              return src ? (
                <img className="favicon" src={src} onError={(e)=>{(e.currentTarget as HTMLImageElement).style.visibility='hidden'}} alt=""/>
              ) : <span style={{ width: 16, height: 16 }} />
            })()}
            <a className="link link-text" href={node.url} target="_blank" rel="noreferrer">
              <TitleWithHighlight text={node.title} q={q} isLink />
            </a>
          </span>
        ) : (
          <span className="node-title"><TitleWithHighlight text={node.title} q={q} /></span>
        )}
        <div className="node-actions">
          {/* Всегда показываем кнопку открытия для ссылок */}
          {isLink && <button className="icon-btn" title="Перейти/открыть" onClick={openHere}>↗</button>}
          {/* Всегда показываем кнопку добавления категории */}
          <button className="icon-btn" title="Добавить категорию" onClick={addCategoryHere}>📁＋</button>
          {/* Всегда показываем кнопку добавления выделенных вкладок */}
          <button className="icon-btn" title="Добавить выделенные вкладки (используйте ПКМ → 'Добавить выделенные вкладки')" onClick={addSelectedTabHere}>🔗↧</button>
          {/* Кнопка для редактирования комментария */}
          <button 
            className={`icon-btn ${node.comment ? 'comment-active' : ''}`} 
            title={node.comment ? `Комментарий: ${node.comment}` : "Добавить комментарий"} 
            onClick={editComment}
          >
            {node.comment ? '💬' : '💬＋'}
          </button>
          {/* Кнопки редактирования и удаления */}
          <button className="icon-btn" title="Переименовать" onClick={startRename}>✏</button>
          <button className="icon-btn" title="Удалить" onClick={deleteNode}>🗑</button>
        </div>
      </div>

      {renaming && (
        <div className="rename-form" onClick={e => e.stopPropagation()}>
          <input
            type="text"
            value={title}
            onChange={e => setTitle(e.target.value)}
            onBlur={commitRename}
            onKeyDown={handleKeyDown}
            autoFocus
          />
        </div>
      )}

      {editingComment && (
        <div className="comment-form" onClick={e => e.stopPropagation()}>
          <textarea
            value={commentText}
            onChange={e => setCommentText(e.target.value)}
            onBlur={commitComment}
            onKeyDown={handleCommentKeyDown}
            placeholder="Введите комментарий..."
            autoFocus
          />
          <div className="comment-form-buttons">
            <button onClick={commitComment}>Сохранить</button>
            <button onClick={() => {
              setCommentText(node.comment || '')
              setEditingComment(false)
            }}>Отмена</button>
          </div>
        </div>
      )}

      {effectiveOpen && hasChildren && (maxLevel < 0 || depth < maxLevel) && (
        <div className="children">
          {node.children!.map(child => (
            <NodeView
              key={child.id}
              node={child}
              q={q}
              allNodes={allNodes}
              setAllNodes={setAllNodes}
              docId={docId}
              docTitle={docTitle}
              forceExpand={forceExpand}
              selectedTab={selectedTab}
              depth={depth + 1}
              maxLevel={maxLevel}
              expandedNodes={expandedNodes}
              onToggleExpanded={onToggleExpanded}
              selectionMode={selectionMode}
              moveMode={moveMode}
              isNodeSelected={isNodeSelected}
              onToggleNodeSelection={onToggleNodeSelection}
              removeNodesFromSelection={removeNodesFromSelection}
              allTrees={allTrees}
              onUpdateTreeNodes={onUpdateTreeNodes}
              globalIsNodeSelected={globalIsNodeSelected}
            />
          ))}
        </div>
      )}
    </div>
  )
}

export default function Tree({
  doc,
  onAddRootCategory,
  onAddCurrentTabToRoot,
  forceExpand,
  selectedTab,
  onCommitNodes,
  uiState,
  onUpdateUIState,
  // Новые пропсы для системы выделения
  selectionMode = false,
  moveMode = false,
  isNodeSelected = () => false,
  onToggleNodeSelection = () => {},
  onDeleteSelected,
  removeNodesFromSelection = () => {},
  // Данные всех деревьев для поддержки межпроектных переносов
  allTrees = [],
  onUpdateTreeNodes,
  globalIsNodeSelected = () => false,
}: Props) {
  const [nodes, setNodes] = useState<TreeNode[]>(doc.nodes)
  const [selectedTabsToAdd, setSelectedTabsToAdd] = useState<chrome.tabs.Tab[]>([])
  const [showAddSelectedTabs, setShowAddSelectedTabs] = useState(false)
  const [addingOffline, setAddingOffline] = useState(false)
  const [offlineProgress, setOfflineProgress] = useState(0)
  const [offlineTotal, setOfflineTotal] = useState(0)
  const [offlineError, setOfflineError] = useState<string | null>(null)
  const mainRef = useRef<HTMLDivElement>(null)

  // Сохраняем позицию прокрутки при изменении
  useEffect(() => {
    const main = mainRef.current
    if (!main) return
    
    const saveScrollPosition = () => {
      onUpdateUIState(prev => ({
        ...prev,
        scrollPosition: main.scrollTop
      }))
    }
    
    main.addEventListener('scroll', saveScrollPosition)
    return () => main.removeEventListener('scroll', saveScrollPosition)
  }, [onUpdateUIState])
  
  // Восстанавливаем позицию прокрутки при монтировании
  useEffect(() => {
    const main = mainRef.current
    if (!main) return
    
    if (uiState.scrollPosition > 0) {
      main.scrollTop = uiState.scrollPosition
    }
  }, [uiState.scrollPosition])

  // Обновляем локальное состояние при изменении doc.nodes
  useEffect(() => {
    setNodes(doc.nodes)
  }, [doc.nodes])

  // Сохраняем изменения в хранилище
  useEffect(() => {
    const commitChanges = async () => {
      try {
        if (onCommitNodes) {
          await onCommitNodes(doc.id, nodes)
        } else {
          await upsertNodes(doc.id, nodes)
        }
      } catch (error) {
        console.error('Failed to commit nodes:', error)
      }
    }

    const timer = setTimeout(commitChanges, 300)
    return () => clearTimeout(timer)
  }, [nodes, doc.id, onCommitNodes])

  // Обработчик для добавления категории в корень
  const handleAddRootCategory = () => {
    onAddRootCategory()
  }

  // Обработчик для добавления текущей вкладки в корень
  const handleAddCurrentTabToRoot = () => {
    onAddCurrentTabToRoot()
  }

  // Обработчик для добавления выделенных вкладок в корень
  const handleAddSelectedTabsToRoot = async () => {
    try {
      if (selectionMode) {
        // В режиме выделения - добавляем выделенные элементы в корень
        const universalItems = getUniversalItemsToAdd(
          allTrees.flatMap(tree => 
            Array.from(globalIsNodeSelected ? 
              tree.nodes.filter(n => globalIsNodeSelected(tree.id, n.id)).map(n => ({
                treeId: tree.id,
                nodeId: n.id,
                title: n.title,
                url: n.url
              })) : []
            )
          ),
          allTrees
        )
        
        if (universalItems.length === 0) {
          alert('Нет выделенных элементов для добавления')
          return
        }
        
        // Получаем описание операции
        const description = getSourceDescription(universalItems)
        
        // Подтверждение операции
        const confirmMessage = moveMode 
          ? `Переместить ${description} в корень дерева?`
          : `Копировать ${description} в корень дерева?`
          
        if (!confirm(confirmMessage)) return
        
        // Создаем новые узлы из универсальных элементов
        const newNodes = universalItems
          .map(item => universalItemToTreeNode(item))
          .filter(Boolean) as TreeNode[]
          
        if (newNodes.length === 0) return
        
        // Добавляем узлы в корень текущего дерева
        setNodes(prev => [...prev, ...newNodes])
        
        // Если в режиме перемещения, удаляем исходные узлы
        if (moveMode) {
          // Группируем по деревьям для оптимизации
          const nodesByTree: Record<string, string[]> = {}
          
          universalItems.forEach(item => {
            if (!item.treeId || !item.nodeId) return
            
            if (!nodesByTree[item.treeId]) {
              nodesByTree[item.treeId] = []
            }
            nodesByTree[item.treeId].push(item.nodeId)
          })
          
          // Удаляем из каждого дерева
          for (const [treeId, nodeIds] of Object.entries(nodesByTree)) {
            // Если это текущее дерево, обновляем локальное состояние
            if (treeId === doc.id) {
              // Для внутридеревного перемещения используем специальную функцию
              const result = deleteSourceNodesForIntraTreeMove(nodes, nodeIds)
              if (result) {
                setNodes(result)
              }
            } else if (onUpdateTreeNodes) {
              // Для междеревного перемещения обновляем через пропсы
              const sourceTree = allTrees.find(t => t.id === treeId)
              if (sourceTree) {
                const updatedSourceNodes = removeMultipleNodes(sourceTree.nodes, nodeIds)
                await onUpdateTreeNodes(treeId, updatedSourceNodes)
              }
            }
            
            // Удаляем из выделения
            removeNodesFromSelection(treeId, nodeIds)
          }
        }
      } else {
        // В обычном режиме - показываем диалог выбора вкладок
        const tabs = await pTabsQuery({ currentWindow: true })
        const normalTabs = tabs.filter(isNormalTab)
        setSelectedTabsToAdd(normalTabs)
        setShowAddSelectedTabs(true)
      }
    } catch (error) {
      console.error('Error adding selected items to root:', error)
      alert('Ошибка при добавлении элементов в корень')
    }
  }

  // Обработчик для добавления выбранных вкладок
  const handleAddCheckedTabs = (checkedIds: number[]) => {
    setShowAddSelectedTabs(false)
    if (!checkedIds.length) return

    const tabsToAdd = selectedTabsToAdd.filter(t => checkedIds.includes(t.id!))
    const newNodes = tabsToAdd.map(toNode)
    setNodes(prev => [...prev, ...newNodes])
  }

  // Обработчик для сохранения страницы офлайн
  const handleSaveOffline = async () => {
    if (!selectedTab?.id) {
      alert('Нет активной вкладки для сохранения')
      return
    }

    try {
      setAddingOffline(true)
      setOfflineProgress(0)
      setOfflineTotal(1)
      setOfflineError(null)

      // Запрашиваем сохранение через background script
      const result = await chrome.runtime.sendMessage({
        type: 'savePageOffline',
        tabId: selectedTab.id,
        title: selectedTab.title,
        url: selectedTab.url
      })

      if (result.error) {
        setOfflineError(result.error)
        return
      }

      // Добавляем новый узел с информацией о сохраненной странице
      const newNode: TreeNode = {
        id: crypto.randomUUID(),
        title: selectedTab.title || 'Сохраненная страница',
        url: selectedTab.url,
        offlineId: result.downloadId,
        offlinePath: result.filename,
        mime: 'multipart/related',
        children: []
      }

      setNodes(prev => [...prev, newNode])
      setOfflineProgress(1)
    } catch (error) {
      console.error('Failed to save offline:', error)
      setOfflineError(String(error))
    } finally {
      setTimeout(() => setAddingOffline(false), 1000)
    }
  }

  // Обработчик для переключения уровня фильтрации
  const handleLevelFilter = (level: number) => {
    onUpdateUIState(prev => ({
      ...prev,
      filterLevel: level
    }))
  }

  // Обработчик для изменения поискового запроса
  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    onUpdateUIState(prev => ({
      ...prev,
      searchQuery: e.target.value
    }))
  }

  // Обработчик для очистки поиска
  const clearSearch = () => {
    onUpdateUIState(prev => ({
      ...prev,
      searchQuery: ''
    }))
  }

  // Обработчик для переключения раскрытия узла
  const handleToggleExpanded = (nodeId: string, isExpanded: boolean) => {
    onUpdateUIState(prev => {
      const newExpanded = new Set(prev.expandedNodes)
      if (isExpanded) {
        newExpanded.add(nodeId)
      } else {
        newExpanded.delete(nodeId)
      }
      return {
        ...prev,
        expandedNodes: newExpanded
      }
    })
  }

  // Фильтрация дерева по поисковому запросу
  const filteredNodes = useMemo(() => {
    return uiState.searchQuery
      ? filterTree(nodes, uiState.searchQuery)
      : nodes
  }, [nodes, uiState.searchQuery])

  // Обрезка дерева по уровню фильтрации
  const displayNodes = useMemo(() => {
    return uiState.filterLevel >= 0
      ? cutTreeToDepth(filteredNodes, uiState.filterLevel)
      : filteredNodes
  }, [filteredNodes, uiState.filterLevel])

  // Вычисление максимальной глубины дерева
  const maxDepth = useMemo(() => computeMaxDepth(nodes), [nodes])

  return (
    <div className={`tree ${selectionMode ? 'selection-mode' : ''}`}>
      <div className="toolbar">
        <button
          className="add-category-btn"
          onClick={handleAddRootCategory}
          title="Добавить категорию в корень"
        >
          📁＋ В корень
        </button>

        <button
          className="add-tab-btn"
          onClick={handleAddCurrentTabToRoot}
          title="Добавить текущую вкладку в корень"
        >
          🔗↧ В корень
        </button>

        <button
          className="add-selected-tabs-btn"
          onClick={handleAddSelectedTabsToRoot}
          title="Добавить выделенные вкладки или переместить выделенные закладки в корень"
        >
          🔗↧ + Выделенное (в корень)
        </button>

        {/* Фильтр уровней — ТОЛЬКО КЛИК, без hover */}
        <div className="levelbar" aria-label="Фильтр по уровню">
          <span className="muted" style={{ marginRight: 4 }}>Уровень:</span>
          {[...Array(maxDepth + 1)].map((_, i) => (
            <button
              key={i}
              className={uiState.filterLevel === i ? 'active' : ''}
              onClick={() => handleLevelFilter(i)}
              title={`Показать только уровень ${i}`}
            >
              {i}
            </button>
          ))}
          <button
            className={uiState.filterLevel === -1 ? 'active' : ''}
            onClick={() => handleLevelFilter(-1)}
            title="Показать все уровни"
          >
            Все
          </button>
        </div>

        <div className="search-container">
          <input
            type="text"
            className="search-input"
            placeholder="Поиск..."
            value={uiState.searchQuery}
            onChange={handleSearchChange}
          />
          {uiState.searchQuery && (
            <button className="clear-search" onClick={clearSearch} title="Очистить поиск">
              ×
            </button>
          )}
        </div>

        <button
          className="save-offline-btn"
          onClick={handleSaveOffline}
          title="Сохранить текущую страницу для офлайн-доступа (MHTML)"
          disabled={addingOffline}
        >
          + В корень (офлайн)
        </button>
      </div>

      {addingOffline && (
        <div className="offline-progress">
          <div className="progress-bar">
            <div
              className="progress-fill"
              style={{ width: `${(offlineProgress / offlineTotal) * 100}%` }}
            />
          </div>
          <div className="progress-text">
            {offlineError ? (
              <span className="error">{offlineError}</span>
            ) : (
              `Сохранение ${offlineProgress}/${offlineTotal}...`
            )}
          </div>
        </div>
      )}

      <div className="main" ref={mainRef}>
        {displayNodes.length === 0 ? (
          <div className="empty-tree">
            <p>Дерево пусто. Добавьте категории или закладки.</p>
          </div>
        ) : (
          displayNodes.map(node => (
            <NodeView
              key={node.id}
              node={node}
              q={uiState.searchQuery}
              allNodes={nodes}
              setAllNodes={setNodes}
              docId={doc.id}
              docTitle={doc.title}
              forceExpand={forceExpand}
              selectedTab={selectedTab}
              expandedNodes={uiState.expandedNodes}
              onToggleExpanded={handleToggleExpanded}
              selectionMode={selectionMode}
              moveMode={moveMode}
              isNodeSelected={isNodeSelected}
              onToggleNodeSelection={onToggleNodeSelection}
              removeNodesFromSelection={removeNodesFromSelection}
              allTrees={allTrees}
              onUpdateTreeNodes={onUpdateTreeNodes}
              globalIsNodeSelected={globalIsNodeSelected}
            />
          ))
        )}
      </div>

      {showAddSelectedTabs && (
        <TabSelector
          tabs={selectedTabsToAdd}
          onClose={() => setShowAddSelectedTabs(false)}
          onAdd={handleAddCheckedTabs}
        />
      )}
    </div>
  )
}

// Компонент для выбора вкладок
const TabSelector: React.FC<{
  tabs: chrome.tabs.Tab[]
  onClose: () => void
  onAdd: (checkedIds: number[]) => void
}> = ({ tabs, onClose, onAdd }) => {
  const [checkedIds, setCheckedIds] = useState<Set<number>>(new Set())

  const toggleCheck = (id: number) => {
    setCheckedIds(prev => {
      const next = new Set(prev)
      if (next.has(id)) {
        next.delete(id)
      } else {
        next.add(id)
      }
      return next
    })
  }

  const toggleAll = () => {
    if (checkedIds.size === tabs.length) {
      // Если все выбраны - снимаем выделение
      setCheckedIds(new Set())
    } else {
      // Иначе выбираем все
      setCheckedIds(new Set(tabs.map(t => t.id!)))
    }
  }

  const handleAdd = () => {
    onAdd(Array.from(checkedIds))
  }

  return (
    <div className="tab-selector-overlay">
      <div className="tab-selector">
        <div className="tab-selector-header">
          <h3>Выберите вкладки для добавления</h3>
          <button className="close-btn" onClick={onClose}>×</button>
        </div>
        <div className="tab-selector-controls">
          <button onClick={toggleAll}>
            {checkedIds.size === tabs.length ? 'Снять все' : 'Выбрать все'}
          </button>
          <span className="tab-count">
            Выбрано: {checkedIds.size} из {tabs.length}
          </span>
        </div>
        <div className="tab-list">
          {tabs.map(tab => (
            <div
              key={tab.id}
              className={`tab-item ${checkedIds.has(tab.id!) ? 'checked' : ''}`}
              onClick={() => toggleCheck(tab.id!)}
            >
              <div className="tab-checkbox">
                {checkedIds.has(tab.id!) ? '☑' : '☐'}
              </div>
              <div className="tab-favicon">
                {tab.favIconUrl ? (
                  <img
                    src={tab.favIconUrl}
                    alt=""
                    onError={(e) => { (e.target as HTMLImageElement).style.display = 'none' }}
                  />
                ) : null}
              </div>
              <div className="tab-title">{tab.title}</div>
            </div>
          ))}
        </div>
        <div className="tab-selector-footer">
          <button
            className="add-btn"
            onClick={handleAdd}
            disabled={checkedIds.size === 0}
          >
            Добавить выбранные ({checkedIds.size})
          </button>
          <button className="cancel-btn" onClick={onClose}>
            Отмена
          </button>
        </div>
      </div>
    </div>
  )
}