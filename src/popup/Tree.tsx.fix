import React, { useMemo, useRef, useState } from 'react'
import type { TreeDocument, TreeNode, TreeUIState } from '../models'
import { filterTree, highlight } from '../search'
import { insertChild, removeNode, updateNode, moveNode, moveMultipleNodes, updateNodeComment } from '../treeOps'
import { upsertNodes } from './sqlStorage'   // —Ñ–æ–ª–±—ç–∫, –µ—Å–ª–∏ –Ω–µ –ø–µ—Ä–µ–¥–∞–¥—é—Ç onCommitNodes
import { getUniversalItemsToAdd, universalItemToTreeNode, getSourceDescription, copySelectedNodes, deleteSourceNodesForIntraTreeMove } from '../universalAdd'
type Props = {
  doc: TreeDocument
  onAddRootCategory: () => void
  onAddCurrentTabToRoot: () => void
  forceExpand?: boolean
  selectedTab?: { id: number; title: string; url: string } | null
  /** –ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞—Ç—å ‚Äî –∏–º–µ–Ω–Ω–æ –æ–Ω –±—É–¥–µ—Ç –∫–æ–º–º–∏—Ç–∏—Ç—å —É–∑–ª—ã (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –≤—ã–∑—ã–≤–∞—Ç—å App.updateNodesFor) */
  onCommitNodes?: (docId: string, nodes: TreeNode[]) => Promise<void> | void
  // –°–æ—Å—Ç–æ—è–Ω–∏–µ UI –¥–µ—Ä–µ–≤–∞
  uiState: TreeUIState
  onUpdateUIState: (updater: (prev: TreeUIState) => TreeUIState) => void
  // –ù–æ–≤—ã–µ –ø—Ä–æ–ø—Å—ã –¥–ª—è —Å–∏—Å—Ç–µ–º—ã –≤—ã–¥–µ–ª–µ–Ω–∏—è
  selectionMode?: boolean
  moveMode?: boolean
  isNodeSelected?: (nodeId: string) => boolean
  onToggleNodeSelection?: (node: TreeNode) => void
  // –ì—Ä—É–ø–ø–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
  onDeleteSelected?: () => void
  removeNodesFromSelection?: (treeId: string, nodeIds: string[]) => void
  // –î–∞–Ω–Ω—ã–µ –≤—Å–µ—Ö –¥–µ—Ä–µ–≤—å–µ–≤ –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –º–µ–∂–ø—Ä–æ–µ–∫—Ç–Ω—ã—Ö –ø–µ—Ä–µ–Ω–æ—Å–æ–≤
  allTrees?: TreeDocument[]
  onUpdateTreeNodes?: (treeId: string, nodes: TreeNode[]) => Promise<void>
  // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –≤—ã–¥–µ–ª–µ–Ω–∏—è –¥–ª—è –º–µ–∂–¥–µ—Ä–µ–≤–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
  globalIsNodeSelected?: (treeId: string, nodeId: string) => boolean
}

/* ---------- helpers –¥–ª—è Chrome API (Promise-–æ–±—ë—Ä—Ç–∫–∏) ---------- */
function pTabsQuery(q: chrome.tabs.QueryInfo): Promise<chrome.tabs.Tab[]> {
  return new Promise(res => chrome.tabs.query(q, res))
}
function pTabsCreate(c: chrome.tabs.CreateProperties): Promise<chrome.tabs.Tab> {
  return new Promise(res => chrome.tabs.create(c, res))
}
function pTabsUpdate(tabId: number, props: chrome.tabs.UpdateProperties) {
  return new Promise<chrome.tabs.Tab>((res, rej) => {
    chrome.tabs.update(tabId, props, (tab) => {
      if (chrome.runtime.lastError || !tab) return rej(chrome.runtime.lastError ?? new Error("No tab"));
      res(tab);
    });
  });
}
function pWindowsUpdate(windowId: number, props: chrome.windows.UpdateInfo): Promise<chrome.windows.Window | undefined> {
  return new Promise(res => chrome.windows.update(windowId, props, res))
}
function pTabsGroup(opts: chrome.tabs.GroupOptions): Promise<number> {
  return new Promise((res, rej) => chrome.tabs.group(opts, gid => {
    const err = chrome.runtime.lastError
    if (err) rej(err); else res(gid)
  }))
}
function pTabGroupsGet(groupId: number): Promise<chrome.tabGroups.TabGroup> {
  return new Promise((res, rej) => chrome.tabGroups.get(groupId, g => {
    const err = chrome.runtime.lastError
    if (err) rej(err); else res(g)
  }))
}
function pTabGroupsUpdate(groupId: number, info: chrome.tabGroups.UpdateProperties): Promise<chrome.tabGroups.TabGroup> {
  return new Promise((res, rej) => chrome.tabGroups.update(groupId, info, g => {
    const err = chrome.runtime.lastError
    if (err) rej(err); else res(g!)
  }))
}

const normUrl = (u?: string) => (u ? u.split('#')[0] : '')

/** –û—Ç–∫—Ä—ã—Ç—å/–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å URL —Å —É—á—ë—Ç–æ–º –≥—Ä—É–ø–ø –≤–∫–ª–∞–¥–æ–∫. */
async function openOrFocusUrl(url: string, docTitle: string) {
  const target = normUrl(url)
  if (!target) return

  // 1) –£–∂–µ –æ—Ç–∫—Ä—ã—Ç?
  const all = await pTabsQuery({})
  const existing = all.find(t => normUrl(t.url || '') === target)
  if (existing?.id) {
    if (typeof existing.windowId === 'number') await pWindowsUpdate(existing.windowId, { focused: true })
    await pTabsUpdate(existing.id, { active: true })
    return
  }

  // 2) –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ "—Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–π" –≤–∫–ª–∞–¥–∫–µ –∏ –≥—Ä—É–ø–ø–µ
  const sessionData = await chrome.storage.session.get(['vb_lastActiveTabId', 'vb_lastActiveGroupId']);
  const parentTabId = sessionData.vb_lastActiveTabId;
  const parentGroupId = sessionData.vb_lastActiveGroupId;

  const [activeWinTab] = await pTabsQuery({ active: true, currentWindow: true })
  const winId = activeWinTab?.windowId ?? (await pTabsQuery({ currentWindow: true }))[0]?.windowId
  const created = await pTabsCreate({ url: target, active: true, windowId: winId })

  if (!chrome.tabGroups || typeof created.id !== 'number') return

  // 3) –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç—ã –¥–ª—è –≤—ã–±–æ—Ä–∞ –≥—Ä—É–ø–ø—ã:
  // –∞) –ì—Ä—É–ø–ø–∞ —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º –¥–µ—Ä–µ–≤–∞
  const tabsInWindow = await pTabsQuery({ windowId: created.windowId })
  const uniqueGroupIds = Array.from(new Set(
    tabsInWindow.map(t => (typeof t.groupId === 'number' ? t.groupId : -1)).filter(gid => gid >= 0)
  ))
  let targetGroupId: number | null = null
  for (const gid of uniqueGroupIds) {
    try {
      const g = await pTabGroupsGet(gid)
      if (g.title === docTitle) { targetGroupId = gid; break }
    } catch {}
  }
  if (targetGroupId !== null) { await pTabsGroup({ tabIds: created.id, groupId: targetGroupId }); return }

  // –±) –ì—Ä—É–ø–ø–∞ "—Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–π" –≤–∫–ª–∞–¥–∫–∏
  if (typeof parentGroupId === 'number' && parentGroupId >= 0) {
    try {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≥—Ä—É–ø–ø–∞ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ —Ç–æ–º –∂–µ –æ–∫–Ω–µ
      const groupStillExists = uniqueGroupIds.includes(parentGroupId);
      if (groupStillExists) {
        await pTabsGroup({ tabIds: created.id, groupId: parentGroupId });
        return;
      }
    } catch {}
  }

  // –≤) –ì—Ä—É–ø–ø–∞ —Ç–µ–∫—É—â–µ–π –∞–∫—Ç–∏–≤–Ω–æ–π –≤–∫–ª–∞–¥–∫–∏ (–∑–∞–ø–∞—Å–Ω–æ–π –≤–∞—Ä–∏–∞–Ω—Ç)
  const activeGroupId = (activeWinTab && typeof activeWinTab.groupId === 'number' && activeWinTab.groupId >= 0)
    ? activeWinTab.groupId : -1
  if (activeGroupId >= 0) { await pTabsGroup({ tabIds: created.id, groupId: activeGroupId }); return }

  // –≥) –°–æ–∑–¥–∞—ë–º –Ω–æ–≤—É—é –≥—Ä—É–ø–ø—É —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º –¥–µ—Ä–µ–≤–∞
  try {
    const newGroupId = await pTabsGroup({ tabIds: created.id })
    await pTabGroupsUpdate(newGroupId, { title: docTitle })
  } catch {}
}

/* ---------- helpers –¥–ª—è ¬´–≤—ã–¥–µ–ª–µ–Ω–Ω—ã—Ö –≤–∫–ª–∞–¥–æ–∫¬ª ---------- */
const isNormalTab = (t: chrome.tabs.Tab) =>
  !!(t.url && !t.url.startsWith('chrome://') && !t.url.startsWith('chrome-extension://'))

const toNode = (t: chrome.tabs.Tab): TreeNode => ({
  id: crypto.randomUUID(),
  title: (t.title || t.url || '').trim() || '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è',
  url: t.url || '',
  children: []
})


/* ------------------- UI helpers ------------------- */

const TitleWithHighlight: React.FC<{ text: string, q: string, isLink?: boolean }> = ({ text, q, isLink }) => {
  const parts = useMemo(() => highlight(text, q), [text, q])
  return (
    <>
      {parts.map((p,i)=> typeof p==='string' ? <span key={i}>{p}</span> : <mark key={i}>{p.mark}</mark>)}
      {isLink && <span className="muted"> ‚Üó</span>}
    </>
  )
}

function faviconForUrl(url?: string): string {
  if (!url) return ''
  if (!/^https?:/i.test(url)) return ''
  return `https://www.google.com/s2/favicons?domain_url=${encodeURIComponent(url)}&sz=16`
}

/** max –≥–ª—É–±–∏–Ω–∞ –¥–µ—Ä–µ–≤–∞ */
function computeMaxDepth(nodes: TreeNode[], depth = 0): number {
  let m = depth
  for (const n of nodes) m = Math.max(m, computeMaxDepth(n.children || [], depth + 1))
  return m
}

/** –û–±—Ä–µ–∑–∫–∞ –¥–µ—Ä–µ–≤–∞ –¥–æ depth (–≤–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ). depth=-1 ‚Äî –±–µ–∑ –æ–±—Ä–µ–∑–∫–∏ */
function cutTreeToDepth(nodes: TreeNode[], depth: number, cur = 0): TreeNode[] {
  if (depth < 0) return nodes
  return nodes.map(n => ({
    ...n,
    children: cur >= depth ? [] : cutTreeToDepth(n.children || [], depth, cur + 1)
  }))
}

const NodeView: React.FC<{
  node: TreeNode
  q: string
  allNodes: TreeNode[]
  setAllNodes: (ns: TreeNode[]) => void
  docId: string
  docTitle: string
  forceExpand?: boolean
  selectedTab?: { id: number; title: string; url: string } | null
  depth?: number
  maxLevel?: number
  expandedNodes: Set<string>
  onToggleExpanded: (nodeId: string, isExpanded: boolean) => void
  // –ù–æ–≤—ã–µ –ø—Ä–æ–ø—Å—ã –¥–ª—è —Å–∏—Å—Ç–µ–º—ã –≤—ã–¥–µ–ª–µ–Ω–∏—è
  selectionMode?: boolean
  moveMode?: boolean
  isNodeSelected?: (nodeId: string) => boolean
  onToggleNodeSelection?: (node: TreeNode) => void
  removeNodesFromSelection?: (treeId: string, nodeIds: string[]) => void
  // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–≥–æ –ø–µ—Ä–µ–Ω–æ—Å–∞
  allTrees?: TreeDocument[]
  onUpdateTreeNodes?: (treeId: string, nodes: TreeNode[]) => Promise<void>
  globalIsNodeSelected?: (treeId: string, nodeId: string) => boolean
}> = ({
  node,
  q,
  allNodes,
  setAllNodes,
  docId,
  docTitle,
  forceExpand,
  selectedTab,
  depth = 0,
  maxLevel = -1,
  expandedNodes,
  onToggleExpanded,
  // –ù–æ–≤—ã–µ –ø—Ä–æ–ø—Å—ã –¥–ª—è —Å–∏—Å—Ç–µ–º—ã –≤—ã–¥–µ–ª–µ–Ω–∏—è
  selectionMode = false,
  moveMode = false,
  isNodeSelected = () => false,
  onToggleNodeSelection = () => {},
  removeNodesFromSelection = () => {},
  // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–≥–æ –ø–µ—Ä–µ–Ω–æ—Å–∞
  allTrees = [],
  onUpdateTreeNodes,
  globalIsNodeSelected = () => false,
}) => {
  const [renaming, setRenaming] = useState(false)
  const [title, setTitle] = useState(node.title)
  const [commentText, setCommentText] = useState(node.comment || '')
  const [editingComment, setEditingComment] = useState(false)
  const isLink = !!node.url
  const hasChildren = (node.children?.length || 0) > 0
  const isSelected = isNodeSelected(node.id)

  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, —Ä–∞–∑–≤—ë—Ä–Ω—É—Ç –ª–∏ —É–∑–µ–ª
  const isExpanded = expandedNodes.has(node.id)
  const isExplicitlyClosed = expandedNodes.has(`closed:${node.id}`)
  const effectiveOpen = forceExpand ? !isExplicitlyClosed : isExpanded

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
  const onDragStart = (e: React.DragEvent) => {
    e.stopPropagation()
    e.dataTransfer.setData('text/plain', JSON.stringify({
      nodeId: node.id,
      docId,
      title: node.title,
      url: node.url,
    }))
  }

  const onDragOver = (e: React.DragEvent) => {
    e.preventDefault()
    e.stopPropagation()
  }

  const onDrop = async (e: React.DragEvent) => {
    e.preventDefault()
    e.stopPropagation()

    try {
      const data = JSON.parse(e.dataTransfer.getData('text/plain'))
      if (!data?.nodeId) return

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø—ã—Ç–∞–µ–º—Å—è –ª–∏ –º—ã –ø–µ—Ä–µ—Ç–∞—â–∏—Ç—å —É–∑–µ–ª –Ω–∞ —Å–∞–º–æ–≥–æ —Å–µ–±—è
      if (data.nodeId === node.id) return

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø—ã—Ç–∞–µ–º—Å—è –ª–∏ –º—ã –ø–µ—Ä–µ—Ç–∞—â–∏—Ç—å —Ä–æ–¥–∏—Ç–µ–ª—è –Ω–∞ –µ–≥–æ –ø–æ—Ç–æ–º–∫–∞
      let isDescendant = false
      const checkDescendant = (nodes: TreeNode[], targetId: string): boolean => {
        for (const n of nodes) {
          if (n.id === targetId) return true
          if (n.children && checkDescendant(n.children, targetId)) return true
        }
        return false
      }

      if (data.docId === docId) {
        const findNode = (nodes: TreeNode[], id: string): TreeNode | null => {
          for (const n of nodes) {
            if (n.id === id) return n
            if (n.children) {
              const found = findNode(n.children, id)
              if (found) return found
            }
          }
          return null
        }
        const draggedNode = findNode(allNodes, data.nodeId)
        if (draggedNode && draggedNode.children) {
          isDescendant = checkDescendant(draggedNode.children, node.id)
        }
      }

      if (isDescendant) {
        console.warn('Cannot move parent to its descendant')
        return
      }

      // –ï—Å–ª–∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ–º –∏–∑ —Ç–æ–≥–æ –∂–µ –¥–µ—Ä–µ–≤–∞
      if (data.docId === docId) {
        // –í–Ω—É—Ç—Ä–∏ –æ–¥–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞ - –∏—Å–ø–æ–ª—å–∑—É–µ–º moveNode
        const newNodes = moveNode(allNodes, data.nodeId, node.id)
        if (newNodes) {
          setAllNodes(newNodes)
          // –†–∞—Å–∫—Ä—ã–≤–∞–µ–º —É–∑–µ–ª, –≤ –∫–æ—Ç–æ—Ä—ã–π –ø–µ—Ä–µ—Ç–∞—â–∏–ª–∏
          onToggleExpanded(node.id, true)
        }
      } else {
        // –ú–µ–∂–¥—É –¥–µ—Ä–µ–≤—å—è–º–∏ - –∏—Å–ø–æ–ª—å–∑—É–µ–º —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –ø–µ—Ä–µ–Ω–æ—Å
        // –ü–æ–ª—É—á–∞–µ–º –∏—Å—Ö–æ–¥–Ω–æ–µ –¥–µ—Ä–µ–≤–æ
        const sourceTree = allTrees.find(t => t.id === data.docId)
        if (!sourceTree || !onUpdateTreeNodes) return

        // –°–æ–∑–¥–∞–µ–º —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –¥–ª—è –ø–µ—Ä–µ–Ω–æ—Å–∞
        const universalItems = getUniversalItemsToAdd([{
          treeId: data.docId,
          nodeId: data.nodeId,
          title: data.title,
          url: data.url
        }], allTrees)

        if (universalItems.length === 0) return

        // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ —É–∑–µ–ª –¥–µ—Ä–µ–≤–∞
        const newNode = universalItemToTreeNode(universalItems[0])
        if (!newNode) return

        // –î–æ–±–∞–≤–ª—è–µ–º –≤ —Ü–µ–ª–µ–≤–æ–µ –¥–µ—Ä–µ–≤–æ
        const updatedNodes = insertChild(allNodes, node.id, newNode)
        setAllNodes(updatedNodes)
        
        // –£–¥–∞–ª—è–µ–º –∏–∑ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞
        const sourceNodes = sourceTree.nodes.filter(n => n.id !== data.nodeId)
        await onUpdateTreeNodes(data.docId, sourceNodes)

        // –†–∞—Å–∫—Ä—ã–≤–∞–µ–º —É–∑–µ–ª, –≤ –∫–æ—Ç–æ—Ä—ã–π –ø–µ—Ä–µ—Ç–∞—â–∏–ª–∏
        onToggleExpanded(node.id, true)
      }
    } catch (error) {
      console.error('Error during drag and drop:', error)
    }
  }

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
  const startRename = (e: React.MouseEvent) => {
    e.stopPropagation()
    setRenaming(true)
  }

  const commitRename = () => {
    if (title.trim() === '') {
      setTitle(node.title)
      setRenaming(false)
      return
    }

    if (title !== node.title) {
      const newNodes = updateNode(allNodes, node.id, { title })
      if (newNodes) setAllNodes(newNodes)
    }
    setRenaming(false)
  }

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      e.preventDefault()
      commitRename()
    } else if (e.key === 'Escape') {
      e.preventDefault()
      setTitle(node.title)
      setRenaming(false)
    }
  }

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è
  const editComment = (e: React.MouseEvent) => {
    e.stopPropagation()
    setCommentText(node.comment || '')
    setEditingComment(true)
  }

  const commitComment = () => {
    const trimmedComment = commentText.trim()
    const newComment = trimmedComment === '' ? undefined : trimmedComment
    
    if (newComment !== node.comment) {
      const newNodes = updateNodeComment(allNodes, node.id, newComment)
      if (newNodes) setAllNodes(newNodes)
    }
    setEditingComment(false)
  }

  const handleCommentKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      commitComment()
    } else if (e.key === 'Escape') {
      e.preventDefault()
      setCommentText(node.comment || '')
      setEditingComment(false)
    }
  }

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è
  const addCategoryHere = (e: React.MouseEvent) => {
    e.stopPropagation()
    const title = prompt('–ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏:')
    if (!title) return

    const newNode: TreeNode = {
      id: crypto.randomUUID(),
      title,
      children: []
    }

    const newNodes = insertChild(allNodes, node.id, newNode)
    if (newNodes) {
      setAllNodes(newNodes)
      onToggleExpanded(node.id, true)
    }
  }

  const addSelectedTabHere = async (e: React.MouseEvent) => {
    e.stopPropagation()
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤ —Ä–µ–∂–∏–º–µ –≤—ã–¥–µ–ª–µ–Ω–∏—è –∏–ª–∏ –Ω–µ—Ç
    if (selectionMode) {
      // –í —Ä–µ–∂–∏–º–µ –≤—ã–¥–µ–ª–µ–Ω–∏—è - –¥–æ–±–∞–≤–ª—è–µ–º –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
      try {
        // –ü–æ–ª—É—á–∞–µ–º —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è
        const universalItems = getUniversalItemsToAdd(
          allTrees.flatMap(tree => 
            Array.from(globalIsNodeSelected ? 
              tree.nodes.filter(n => globalIsNodeSelected(tree.id, n.id)).map(n => ({
                treeId: tree.id,
                nodeId: n.id,
                title: n.title,
                url: n.url
              })) : []
            )
          ),
          allTrees
        )
        
        if (universalItems.length === 0) {
          alert('–ù–µ—Ç –≤—ã–¥–µ–ª–µ–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è')
          return
        }
        
        // –ü–æ–ª—É—á–∞–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
        const description = getSourceDescription(universalItems)
        
        // –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
        const confirmMessage = moveMode 
          ? `–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å ${description} –≤ "${node.title}"?`
          : `–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å ${description} –≤ "${node.title}"?`
          
        if (!confirm(confirmMessage)) return
        
        // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–µ —É–∑–ª—ã –∏–∑ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
        const newNodes = universalItems
          .map(item => universalItemToTreeNode(item))
          .filter(Boolean) as TreeNode[]
          
        if (newNodes.length === 0) return
        
        // –î–æ–±–∞–≤–ª—è–µ–º —É–∑–ª—ã –≤ —Ç–µ–∫—É—â–µ–µ –¥–µ—Ä–µ–≤–æ
        let updatedNodes = [...allNodes]
        for (const newNode of newNodes) {
          updatedNodes = insertChild(updatedNodes, node.id, newNode)
        }
        
        setAllNodes(updatedNodes)
        onToggleExpanded(node.id, true)
        
        // –ï—Å–ª–∏ –≤ —Ä–µ–∂–∏–º–µ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è, —É–¥–∞–ª—è–µ–º –∏—Å—Ö–æ–¥–Ω—ã–µ —É–∑–ª—ã
        if (moveMode) {
          // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ –¥–µ—Ä–µ–≤—å—è–º –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
          const nodesByTree: Record<string, string[]> = {}
          
          universalItems.forEach(item => {
            if (!item.treeId || !item.nodeId) return
            
            if (!nodesByTree[item.treeId]) {
              nodesByTree[item.treeId] = []
            }
            nodesByTree[item.treeId].push(item.nodeId)
          })
          
          // –£–¥–∞–ª—è–µ–º –∏–∑ –∫–∞–∂–¥–æ–≥–æ –¥–µ—Ä–µ–≤–∞
          for (const [treeId, nodeIds] of Object.entries(nodesByTree)) {
            // –ï—Å–ª–∏ —ç—Ç–æ —Ç–µ–∫—É—â–µ–µ –¥–µ—Ä–µ–≤–æ, –æ–±–Ω–æ–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            if (treeId === docId) {
              // –î–ª—è –≤–Ω—É—Ç—Ä–∏–¥–µ—Ä–µ–≤–Ω–æ–≥–æ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é
              const result = deleteSourceNodesForIntraTreeMove(updatedNodes, nodeIds)
              if (result) {
                setAllNodes(result)
              }
            } else if (onUpdateTreeNodes) {
              // –î–ª—è –º–µ–∂–¥–µ—Ä–µ–≤–Ω–æ–≥–æ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è –æ–±–Ω–æ–≤–ª—è–µ–º —á–µ—Ä–µ–∑ –ø—Ä–æ–ø—Å—ã
              const sourceTree = allTrees.find(t => t.id === treeId)
              if (sourceTree) {
                const updatedSourceNodes = removeMultipleNodes(sourceTree.nodes, nodeIds)
                await onUpdateTreeNodes(treeId, updatedSourceNodes)
              }
            }
            
            // –£–¥–∞–ª—è–µ–º –∏–∑ –≤—ã–¥–µ–ª–µ–Ω–∏—è
            removeNodesFromSelection(treeId, nodeIds)
          }
        }
        
      } catch (error) {
        console.error('Error adding selected items:', error)
        alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –≤—ã–¥–µ–ª–µ–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤')
      }
    } else {
      // –í –æ–±—ã—á–Ω–æ–º —Ä–µ–∂–∏–º–µ - –¥–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—É—â—É—é –≤–∫–ª–∞–¥–∫—É
      if (!selectedTab) {
        alert('–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –≤–∫–ª–∞–¥–∫–∏ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è')
        return
      }
      
      const newNode: TreeNode = {
        id: crypto.randomUUID(),
        title: selectedTab.title || selectedTab.url || '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è',
        url: selectedTab.url,
        children: []
      }
      
      const newNodes = insertChild(allNodes, node.id, newNode)
      if (newNodes) {
        setAllNodes(newNodes)
        onToggleExpanded(node.id, true)
      }
    }
  }

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è
  const deleteNode = (e: React.MouseEvent) => {
    e.stopPropagation()
    if (!confirm(`–£–¥–∞–ª–∏—Ç—å "${node.title}"?`)) return

    const newNodes = removeNode(allNodes, node.id)
    if (newNodes) setAllNodes(newNodes)
  }

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è —Å—Å—ã–ª–∫–∏
  const openHere = async (e: React.MouseEvent) => {
    e.stopPropagation()
    if (!node.url) return
    await openOrFocusUrl(node.url, docTitle)
  }

  const handleRowClick = (e: React.MouseEvent) => {
    if (selectionMode && onToggleNodeSelection) {
      // –í —Ä–µ–∂–∏–º–µ –≤—ã–¥–µ–ª–µ–Ω–∏—è - –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ
      e.stopPropagation()
      onToggleNodeSelection(node)
      return
    }
    
    // –û–±—ã—á–Ω—ã–π —Ä–µ–∂–∏–º - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–∞—Å–∫—Ä—ã—Ç–∏–µ–º –∏–ª–∏ –æ—Ç–∫—Ä—ã—Ç–∏–µ —Å—Å—ã–ª–∫–∏
    if (!isLink || hasChildren) {
      // –ü—Ä–∏ –∫–ª–∏–∫–µ –ø–æ–º–µ—á–∞–µ–º —É–∑–µ–ª –∫–∞–∫ —è–≤–Ω–æ —É–ø—Ä–∞–≤–ª—è–µ–º—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
      if (isExpanded) {
        // –°–≤–æ—Ä–∞—á–∏–≤–∞–µ–º: —É–¥–∞–ª—è–µ–º –∏–∑ expanded, –¥–æ–±–∞–≤–ª—è–µ–º –≤ closed
        onToggleExpanded(node.id, false)
        onToggleExpanded(`closed:${node.id}`, true)
      } else {
        // –†–∞—Å–∫—Ä—ã–≤–∞–µ–º: –¥–æ–±–∞–≤–ª—è–µ–º –≤ expanded, —É–¥–∞–ª—è–µ–º –∏–∑ closed
        onToggleExpanded(node.id, true)
        onToggleExpanded(`closed:${node.id}`, false)
      }
    } else if (isLink && !hasChildren) {
      // –û—Ç–∫—Ä—ã–≤–∞–µ–º —Å—Å—ã–ª–∫—É —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —É –Ω–µ–µ –Ω–µ—Ç –¥–æ—á–µ—Ä–Ω–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
      openHere(e as any)
    }
  }

  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–ª–∞—Å—Å –¥–ª—è —Ç–æ—á–∫–∏ —É–∑–ª–∞
  const getDotClass = () => {
    if (isLink) {
      // –°—Å—ã–ª–∫–∞ —Å –¥–æ—á–µ—Ä–Ω–∏–º–∏ —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏
      if (hasChildren) {
        return 'link-parent'
      }
      // –û–±—ã—á–Ω–∞—è —Å—Å—ã–ª–∫–∞
      return 'link'
    }
    // –ü–∞–ø–∫–∞
    return 'folder'
  }

  return (
    <div className="node" draggable onDragStart={onDragStart} onDragOver={onDragOver} onDrop={onDrop}>
      <div
        className={`node-row ${isSelected ? 'selected' : ''} ${node.comment ? 'has-comment' : ''}`}
        role="treeitem"
        aria-expanded={(!isLink || hasChildren) ? effectiveOpen : undefined}
        tabIndex={-1}
        data-node-id={node.id}
        onClick={handleRowClick}
      >
        {selectionMode && (
          <div 
            className={`selection-checkbox ${isSelected ? 'checked' : ''}`}
            onClick={(e) => {
              e.stopPropagation()
              onToggleNodeSelection?.(node)
            }}
          />
        )}
        <span className={'dot ' + getDotClass()} title={effectiveOpen ? '–°–≤–µ—Ä–Ω—É—Ç—å' : '–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å'} />
        {isLink ? (
          <span className="link-wrap">
            {(() => {
              const src = faviconForUrl(node.url)
              return src ? (
                <img className="favicon" src={src} onError={(e)=>{(e.currentTarget as HTMLImageElement).style.visibility='hidden'}} alt=""/>
              ) : <span style={{ width: 16, height: 16 }} />
            })()}
            <a className="link link-text" href={node.url} target="_blank" rel="noreferrer">
              <TitleWithHighlight text={node.title} q={q} isLink />
            </a>
          </span>
        ) : (
          <span className="node-title"><TitleWithHighlight text={node.title} q={q} /></span>
        )}
        <div className="node-actions">
          {/* –í—Å–µ–≥–¥–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É –æ—Ç–∫—Ä—ã—Ç–∏—è –¥–ª—è —Å—Å—ã–ª–æ–∫ */}
          {isLink && <button className="icon-btn" title="–ü–µ—Ä–µ–π—Ç–∏/–æ—Ç–∫—Ä—ã—Ç—å" onClick={openHere}>‚Üó</button>}
          {/* –í—Å–µ–≥–¥–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ */}
          <button className="icon-btn" title="–î–æ–±–∞–≤–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é" onClick={addCategoryHere}>üìÅÔºã</button>
          {/* –í—Å–µ–≥–¥–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤—ã–¥–µ–ª–µ–Ω–Ω—ã—Ö –≤–∫–ª–∞–¥–æ–∫ */}
          <button className="icon-btn" title="–î–æ–±–∞–≤–∏—Ç—å –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–µ –≤–∫–ª–∞–¥–∫–∏ (–∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ü–ö–ú ‚Üí '–î–æ–±–∞–≤–∏—Ç—å –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–µ –≤–∫–ª–∞–¥–∫–∏')" onClick={addSelectedTabHere}>üîó‚Üß</button>
          {/* –ö–Ω–æ–ø–∫–∞ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è */}
          <button 
            className={`icon-btn ${node.comment ? 'comment-active' : ''}`} 
            title={node.comment ? `–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π: ${node.comment}` : "–î–æ–±–∞–≤–∏—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π"} 
            onClick={editComment}
          >
            {node.comment ? 'üí¨' : 'üí¨Ôºã'}
          </button>
          {/* –ö–Ω–æ–ø–∫–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏ —É–¥–∞–ª–µ–Ω–∏—è */}
          <button className="icon-btn" title="–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å" onClick={startRename}>‚úè</button>
          <button className="icon-btn" title="–£–¥–∞–ª–∏—Ç—å" onClick={deleteNode}>üóë</button>
        </div>
      </div>

      {renaming && (
        <div className="rename-form" onClick={e => e.stopPropagation()}>
          <input
            type="text"
            value={title}
            onChange={e => setTitle(e.target.value)}
            onBlur={commitRename}
            onKeyDown={handleKeyDown}
            autoFocus
          />
        </div>
      )}

      {editingComment && (
        <div className="comment-form" onClick={e => e.stopPropagation()}>
          <textarea
            value={commentText}
            onChange={e => setCommentText(e.target.value)}
            onBlur={commitComment}
            onKeyDown={handleCommentKeyDown}
            placeholder="–í–≤–µ–¥–∏—Ç–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π..."
            autoFocus
          />
          <div className="comment-form-buttons">
            <button onClick={commitComment}>–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
            <button onClick={() => {
              setCommentText(node.comment || '')
              setEditingComment(false)
            }}>–û—Ç–º–µ–Ω–∞</button>
          </div>
        </div>
      )}

      {effectiveOpen && hasChildren && (maxLevel < 0 || depth < maxLevel) && (
        <div className="children">
          {node.children!.map(child => (
            <NodeView
              key={child.id}
              node={child}
              q={q}
              allNodes={allNodes}
              setAllNodes={setAllNodes}
              docId={docId}
              docTitle={docTitle}
              forceExpand={forceExpand}
              selectedTab={selectedTab}
              depth={depth + 1}
              maxLevel={maxLevel}
              expandedNodes={expandedNodes}
              onToggleExpanded={onToggleExpanded}
              selectionMode={selectionMode}
              moveMode={moveMode}
              isNodeSelected={isNodeSelected}
              onToggleNodeSelection={onToggleNodeSelection}
              removeNodesFromSelection={removeNodesFromSelection}
              allTrees={allTrees}
              onUpdateTreeNodes={onUpdateTreeNodes}
              globalIsNodeSelected={globalIsNodeSelected}
            />
          ))}
        </div>
      )}
    </div>
  )
}

export default function Tree({
  doc,
  onAddRootCategory,
  onAddCurrentTabToRoot,
  forceExpand,
  selectedTab,
  onCommitNodes,
  uiState,
  onUpdateUIState,
  // –ù–æ–≤—ã–µ –ø—Ä–æ–ø—Å—ã –¥–ª—è —Å–∏—Å—Ç–µ–º—ã –≤—ã–¥–µ–ª–µ–Ω–∏—è
  selectionMode = false,
  moveMode = false,
  isNodeSelected = () => false,
  onToggleNodeSelection = () => {},
  onDeleteSelected,
  removeNodesFromSelection = () => {},
  // –î–∞–Ω–Ω—ã–µ –≤—Å–µ—Ö –¥–µ—Ä–µ–≤—å–µ–≤ –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –º–µ–∂–ø—Ä–æ–µ–∫—Ç–Ω—ã—Ö –ø–µ—Ä–µ–Ω–æ—Å–æ–≤
  allTrees = [],
  onUpdateTreeNodes,
  globalIsNodeSelected = () => false,
}: Props) {
  const [nodes, setNodes] = useState<TreeNode[]>(doc.nodes)
  const [selectedTabsToAdd, setSelectedTabsToAdd] = useState<chrome.tabs.Tab[]>([])
  const [showAddSelectedTabs, setShowAddSelectedTabs] = useState(false)
  const [addingOffline, setAddingOffline] = useState(false)
  const [offlineProgress, setOfflineProgress] = useState(0)
  const [offlineTotal, setOfflineTotal] = useState(0)
  const [offlineError, setOfflineError] = useState<string | null>(null)
  const mainRef = useRef<HTMLDivElement>(null)

  // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–∑–∏—Ü–∏—é –ø—Ä–æ–∫—Ä—É—Ç–∫–∏ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏
  useEffect(() => {
    const main = mainRef.current
    if (!main) return
    
    const saveScrollPosition = () => {
      onUpdateUIState(prev => ({
        ...prev,
        scrollPosition: main.scrollTop
      }))
    }
    
    main.addEventListener('scroll', saveScrollPosition)
    return () => main.removeEventListener('scroll', saveScrollPosition)
  }, [onUpdateUIState])
  
  // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –ø—Ä–æ–∫—Ä—É—Ç–∫–∏ –ø—Ä–∏ –º–æ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏
  useEffect(() => {
    const main = mainRef.current
    if (!main) return
    
    if (uiState.scrollPosition > 0) {
      main.scrollTop = uiState.scrollPosition
    }
  }, [uiState.scrollPosition])

  // –û–±–Ω–æ–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ doc.nodes
  useEffect(() => {
    setNodes(doc.nodes)
  }, [doc.nodes])

  // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ
  useEffect(() => {
    const commitChanges = async () => {
      try {
        if (onCommitNodes) {
          await onCommitNodes(doc.id, nodes)
        } else {
          await upsertNodes(doc.id, nodes)
        }
      } catch (error) {
        console.error('Failed to commit nodes:', error)
      }
    }

    const timer = setTimeout(commitChanges, 300)
    return () => clearTimeout(timer)
  }, [nodes, doc.id, onCommitNodes])

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –≤ –∫–æ—Ä–µ–Ω—å
  const handleAddRootCategory = () => {
    onAddRootCategory()
  }

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–π –≤–∫–ª–∞–¥–∫–∏ –≤ –∫–æ—Ä–µ–Ω—å
  const handleAddCurrentTabToRoot = () => {
    onAddCurrentTabToRoot()
  }

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤—ã–¥–µ–ª–µ–Ω–Ω—ã—Ö –≤–∫–ª–∞–¥–æ–∫ –≤ –∫–æ—Ä–µ–Ω—å
  const handleAddSelectedTabsToRoot = async () => {
    try {
      if (selectionMode) {
        // –í —Ä–µ–∂–∏–º–µ –≤—ã–¥–µ–ª–µ–Ω–∏—è - –¥–æ–±–∞–≤–ª—è–µ–º –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ –∫–æ—Ä–µ–Ω—å
        const universalItems = getUniversalItemsToAdd(
          allTrees.flatMap(tree => 
            Array.from(globalIsNodeSelected ? 
              tree.nodes.filter(n => globalIsNodeSelected(tree.id, n.id)).map(n => ({
                treeId: tree.id,
                nodeId: n.id,
                title: n.title,
                url: n.url
              })) : []
            )
          ),
          allTrees
        )
        
        if (universalItems.length === 0) {
          alert('–ù–µ—Ç –≤—ã–¥–µ–ª–µ–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è')
          return
        }
        
        // –ü–æ–ª—É—á–∞–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
        const description = getSourceDescription(universalItems)
        
        // –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
        const confirmMessage = moveMode 
          ? `–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å ${description} –≤ –∫–æ—Ä–µ–Ω—å –¥–µ—Ä–µ–≤–∞?`
          : `–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å ${description} –≤ –∫–æ—Ä–µ–Ω—å –¥–µ—Ä–µ–≤–∞?`
          
        if (!confirm(confirmMessage)) return
        
        // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–µ —É–∑–ª—ã –∏–∑ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
        const newNodes = universalItems
          .map(item => universalItemToTreeNode(item))
          .filter(Boolean) as TreeNode[]
          
        if (newNodes.length === 0) return
        
        // –î–æ–±–∞–≤–ª—è–µ–º —É–∑–ª—ã –≤ –∫–æ—Ä–µ–Ω—å —Ç–µ–∫—É—â–µ–≥–æ –¥–µ—Ä–µ–≤–∞
        setNodes(prev => [...prev, ...newNodes])
        
        // –ï—Å–ª–∏ –≤ —Ä–µ–∂–∏–º–µ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è, —É–¥–∞–ª—è–µ–º –∏—Å—Ö–æ–¥–Ω—ã–µ —É–∑–ª—ã
        if (moveMode) {
          // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ –¥–µ—Ä–µ–≤—å—è–º –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
          const nodesByTree: Record<string, string[]> = {}
          
          universalItems.forEach(item => {
            if (!item.treeId || !item.nodeId) return
            
            if (!nodesByTree[item.treeId]) {
              nodesByTree[item.treeId] = []
            }
            nodesByTree[item.treeId].push(item.nodeId)
          })
          
          // –£–¥–∞–ª—è–µ–º –∏–∑ –∫–∞–∂–¥–æ–≥–æ –¥–µ—Ä–µ–≤–∞
          for (const [treeId, nodeIds] of Object.entries(nodesByTree)) {
            // –ï—Å–ª–∏ —ç—Ç–æ —Ç–µ–∫—É—â–µ–µ –¥–µ—Ä–µ–≤–æ, –æ–±–Ω–æ–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            if (treeId === doc.id) {
              // –î–ª—è –≤–Ω—É—Ç—Ä–∏–¥–µ—Ä–µ–≤–Ω–æ–≥–æ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é
              const result = deleteSourceNodesForIntraTreeMove(nodes, nodeIds)
              if (result) {
                setNodes(result)
              }
            } else if (onUpdateTreeNodes) {
              // –î–ª—è –º–µ–∂–¥–µ—Ä–µ–≤–Ω–æ–≥–æ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è –æ–±–Ω–æ–≤–ª—è–µ–º —á–µ—Ä–µ–∑ –ø—Ä–æ–ø—Å—ã
              const sourceTree = allTrees.find(t => t.id === treeId)
              if (sourceTree) {
                const updatedSourceNodes = removeMultipleNodes(sourceTree.nodes, nodeIds)
                await onUpdateTreeNodes(treeId, updatedSourceNodes)
              }
            }
            
            // –£–¥–∞–ª—è–µ–º –∏–∑ –≤—ã–¥–µ–ª–µ–Ω–∏—è
            removeNodesFromSelection(treeId, nodeIds)
          }
        }
      } else {
        // –í –æ–±—ã—á–Ω–æ–º —Ä–µ–∂–∏–º–µ - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–∏–∞–ª–æ–≥ –≤—ã–±–æ—Ä–∞ –≤–∫–ª–∞–¥–æ–∫
        const tabs = await pTabsQuery({ currentWindow: true })
        const normalTabs = tabs.filter(isNormalTab)
        setSelectedTabsToAdd(normalTabs)
        setShowAddSelectedTabs(true)
      }
    } catch (error) {
      console.error('Error adding selected items to root:', error)
      alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ –∫–æ—Ä–µ–Ω—å')
    }
  }

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –≤–∫–ª–∞–¥–æ–∫
  const handleAddCheckedTabs = (checkedIds: number[]) => {
    setShowAddSelectedTabs(false)
    if (!checkedIds.length) return

    const tabsToAdd = selectedTabsToAdd.filter(t => checkedIds.includes(t.id!))
    const newNodes = tabsToAdd.map(toNode)
    setNodes(prev => [...prev, ...newNodes])
  }

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã –æ—Ñ–ª–∞–π–Ω
  const handleSaveOffline = async () => {
    if (!selectedTab?.id) {
      alert('–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –≤–∫–ª–∞–¥–∫–∏ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è')
      return
    }

    try {
      setAddingOffline(true)
      setOfflineProgress(0)
      setOfflineTotal(1)
      setOfflineError(null)

      // –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —á–µ—Ä–µ–∑ background script
      const result = await chrome.runtime.sendMessage({
        type: 'savePageOffline',
        tabId: selectedTab.id,
        title: selectedTab.title,
        url: selectedTab.url
      })

      if (result.error) {
        setOfflineError(result.error)
        return
      }

      // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π —É–∑–µ–ª —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ
      const newNode: TreeNode = {
        id: crypto.randomUUID(),
        title: selectedTab.title || '–°–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞',
        url: selectedTab.url,
        offlineId: result.downloadId,
        offlinePath: result.filename,
        mime: 'multipart/related',
        children: []
      }

      setNodes(prev => [...prev, newNode])
      setOfflineProgress(1)
    } catch (error) {
      console.error('Failed to save offline:', error)
      setOfflineError(String(error))
    } finally {
      setTimeout(() => setAddingOffline(false), 1000)
    }
  }

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è —É—Ä–æ–≤–Ω—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
  const handleLevelFilter = (level: number) => {
    onUpdateUIState(prev => ({
      ...prev,
      filterLevel: level
    }))
  }

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ–∏—Å–∫–æ–≤–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    onUpdateUIState(prev => ({
      ...prev,
      searchQuery: e.target.value
    }))
  }

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –ø–æ–∏—Å–∫–∞
  const clearSearch = () => {
    onUpdateUIState(prev => ({
      ...prev,
      searchQuery: ''
    }))
  }

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è —Ä–∞—Å–∫—Ä—ã—Ç–∏—è —É–∑–ª–∞
  const handleToggleExpanded = (nodeId: string, isExpanded: boolean) => {
    onUpdateUIState(prev => {
      const newExpanded = new Set(prev.expandedNodes)
      if (isExpanded) {
        newExpanded.add(nodeId)
      } else {
        newExpanded.delete(nodeId)
      }
      return {
        ...prev,
        expandedNodes: newExpanded
      }
    })
  }

  // –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –¥–µ—Ä–µ–≤–∞ –ø–æ –ø–æ–∏—Å–∫–æ–≤–æ–º—É –∑–∞–ø—Ä–æ—Å—É
  const filteredNodes = useMemo(() => {
    return uiState.searchQuery
      ? filterTree(nodes, uiState.searchQuery)
      : nodes
  }, [nodes, uiState.searchQuery])

  // –û–±—Ä–µ–∑–∫–∞ –¥–µ—Ä–µ–≤–∞ –ø–æ —É—Ä–æ–≤–Ω—é —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
  const displayNodes = useMemo(() => {
    return uiState.filterLevel >= 0
      ? cutTreeToDepth(filteredNodes, uiState.filterLevel)
      : filteredNodes
  }, [filteredNodes, uiState.filterLevel])

  // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –≥–ª—É–±–∏–Ω—ã –¥–µ—Ä–µ–≤–∞
  const maxDepth = useMemo(() => computeMaxDepth(nodes), [nodes])

  return (
    <div className={`tree ${selectionMode ? 'selection-mode' : ''}`}>
      <div className="toolbar">
        <button
          className="add-category-btn"
          onClick={handleAddRootCategory}
          title="–î–æ–±–∞–≤–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –≤ –∫–æ—Ä–µ–Ω—å"
        >
          üìÅÔºã –í –∫–æ—Ä–µ–Ω—å
        </button>

        <button
          className="add-tab-btn"
          onClick={handleAddCurrentTabToRoot}
          title="–î–æ–±–∞–≤–∏—Ç—å —Ç–µ–∫—É—â—É—é –≤–∫–ª–∞–¥–∫—É –≤ –∫–æ—Ä–µ–Ω—å"
        >
          üîó‚Üß –í –∫–æ—Ä–µ–Ω—å
        </button>

        <button
          className="add-selected-tabs-btn"
          onClick={handleAddSelectedTabsToRoot}
          title="–î–æ–±–∞–≤–∏—Ç—å –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–µ –≤–∫–ª–∞–¥–∫–∏ –∏–ª–∏ –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–µ –∑–∞–∫–ª–∞–¥–∫–∏ –≤ –∫–æ—Ä–µ–Ω—å"
        >
          üîó‚Üß + –í—ã–¥–µ–ª–µ–Ω–Ω–æ–µ (–≤ –∫–æ—Ä–µ–Ω—å)
        </button>

        {/* –§–∏–ª—å—Ç—Ä —É—Ä–æ–≤–Ω–µ–π ‚Äî –¢–û–õ–¨–ö–û –ö–õ–ò–ö, –±–µ–∑ hover */}
        <div className="levelbar" aria-label="–§–∏–ª—å—Ç—Ä –ø–æ —É—Ä–æ–≤–Ω—é">
          <span className="muted" style={{ marginRight: 4 }}>–£—Ä–æ–≤–µ–Ω—å:</span>
          {[...Array(maxDepth + 1)].map((_, i) => (
            <button
              key={i}
              className={uiState.filterLevel === i ? 'active' : ''}
              onClick={() => handleLevelFilter(i)}
              title={`–ü–æ–∫–∞–∑–∞—Ç—å —Ç–æ–ª—å–∫–æ —É—Ä–æ–≤–µ–Ω—å ${i}`}
            >
              {i}
            </button>
          ))}
          <button
            className={uiState.filterLevel === -1 ? 'active' : ''}
            onClick={() => handleLevelFilter(-1)}
            title="–ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ —É—Ä–æ–≤–Ω–∏"
          >
            –í—Å–µ
          </button>
        </div>

        <div className="search-container">
          <input
            type="text"
            className="search-input"
            placeholder="–ü–æ–∏—Å–∫..."
            value={uiState.searchQuery}
            onChange={handleSearchChange}
          />
          {uiState.searchQuery && (
            <button className="clear-search" onClick={clearSearch} title="–û—á–∏—Å—Ç–∏—Ç—å –ø–æ–∏—Å–∫">
              √ó
            </button>
          )}
        </div>

        <button
          className="save-offline-btn"
          onClick={handleSaveOffline}
          title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–µ–∫—É—â—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –¥–ª—è –æ—Ñ–ª–∞–π–Ω-–¥–æ—Å—Ç—É–ø–∞ (MHTML)"
          disabled={addingOffline}
        >
          + –í –∫–æ—Ä–µ–Ω—å (–æ—Ñ–ª–∞–π–Ω)
        </button>
      </div>

      {addingOffline && (
        <div className="offline-progress">
          <div className="progress-bar">
            <div
              className="progress-fill"
              style={{ width: `${(offlineProgress / offlineTotal) * 100}%` }}
            />
          </div>
          <div className="progress-text">
            {offlineError ? (
              <span className="error">{offlineError}</span>
            ) : (
              `–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ ${offlineProgress}/${offlineTotal}...`
            )}
          </div>
        </div>
      )}

      <div className="main" ref={mainRef}>
        {displayNodes.length === 0 ? (
          <div className="empty-tree">
            <p>–î–µ—Ä–µ–≤–æ –ø—É—Å—Ç–æ. –î–æ–±–∞–≤—å—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏–ª–∏ –∑–∞–∫–ª–∞–¥–∫–∏.</p>
          </div>
        ) : (
          displayNodes.map(node => (
            <NodeView
              key={node.id}
              node={node}
              q={uiState.searchQuery}
              allNodes={nodes}
              setAllNodes={setNodes}
              docId={doc.id}
              docTitle={doc.title}
              forceExpand={forceExpand}
              selectedTab={selectedTab}
              expandedNodes={uiState.expandedNodes}
              onToggleExpanded={handleToggleExpanded}
              selectionMode={selectionMode}
              moveMode={moveMode}
              isNodeSelected={isNodeSelected}
              onToggleNodeSelection={onToggleNodeSelection}
              removeNodesFromSelection={removeNodesFromSelection}
              allTrees={allTrees}
              onUpdateTreeNodes={onUpdateTreeNodes}
              globalIsNodeSelected={globalIsNodeSelected}
            />
          ))
        )}
      </div>

      {showAddSelectedTabs && (
        <TabSelector
          tabs={selectedTabsToAdd}
          onClose={() => setShowAddSelectedTabs(false)}
          onAdd={handleAddCheckedTabs}
        />
      )}
    </div>
  )
}

// –ö–æ–º–ø–æ–Ω–µ–Ω—Ç –¥–ª—è –≤—ã–±–æ—Ä–∞ –≤–∫–ª–∞–¥–æ–∫
const TabSelector: React.FC<{
  tabs: chrome.tabs.Tab[]
  onClose: () => void
  onAdd: (checkedIds: number[]) => void
}> = ({ tabs, onClose, onAdd }) => {
  const [checkedIds, setCheckedIds] = useState<Set<number>>(new Set())

  const toggleCheck = (id: number) => {
    setCheckedIds(prev => {
      const next = new Set(prev)
      if (next.has(id)) {
        next.delete(id)
      } else {
        next.add(id)
      }
      return next
    })
  }

  const toggleAll = () => {
    if (checkedIds.size === tabs.length) {
      // –ï—Å–ª–∏ –≤—Å–µ –≤—ã–±—Ä–∞–Ω—ã - —Å–Ω–∏–º–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ
      setCheckedIds(new Set())
    } else {
      // –ò–Ω–∞—á–µ –≤—ã–±–∏—Ä–∞–µ–º –≤—Å–µ
      setCheckedIds(new Set(tabs.map(t => t.id!)))
    }
  }

  const handleAdd = () => {
    onAdd(Array.from(checkedIds))
  }

  return (
    <div className="tab-selector-overlay">
      <div className="tab-selector">
        <div className="tab-selector-header">
          <h3>–í—ã–±–µ—Ä–∏—Ç–µ –≤–∫–ª–∞–¥–∫–∏ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è</h3>
          <button className="close-btn" onClick={onClose}>√ó</button>
        </div>
        <div className="tab-selector-controls">
          <button onClick={toggleAll}>
            {checkedIds.size === tabs.length ? '–°–Ω—è—Ç—å –≤—Å–µ' : '–í—ã–±—Ä–∞—Ç—å –≤—Å–µ'}
          </button>
          <span className="tab-count">
            –í—ã–±—Ä–∞–Ω–æ: {checkedIds.size} –∏–∑ {tabs.length}
          </span>
        </div>
        <div className="tab-list">
          {tabs.map(tab => (
            <div
              key={tab.id}
              className={`tab-item ${checkedIds.has(tab.id!) ? 'checked' : ''}`}
              onClick={() => toggleCheck(tab.id!)}
            >
              <div className="tab-checkbox">
                {checkedIds.has(tab.id!) ? '‚òë' : '‚òê'}
              </div>
              <div className="tab-favicon">
                {tab.favIconUrl ? (
                  <img
                    src={tab.favIconUrl}
                    alt=""
                    onError={(e) => { (e.target as HTMLImageElement).style.display = 'none' }}
                  />
                ) : null}
              </div>
              <div className="tab-title">{tab.title}</div>
            </div>
          ))}
        </div>
        <div className="tab-selector-footer">
          <button
            className="add-btn"
            onClick={handleAdd}
            disabled={checkedIds.size === 0}
          >
            –î–æ–±–∞–≤–∏—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—ã–µ ({checkedIds.size})
          </button>
          <button className="cancel-btn" onClick={onClose}>
            –û—Ç–º–µ–Ω–∞
          </button>
        </div>
      </div>
    </div>
  )
}